## Đây là Docs tự research:

## HTTP Request là gì? Các phương thức HTTP request ?

- HTTP (Hypertext Transfer Protocol) là một giao thức truyền tải dữ liệu qua mạng được sử dụng rộng rãi trên internet. Nó định nghĩa cách các máy tính giao tiếp và trao đổi thông tin với nhau.

- Trong HTTP, các phương thức (methods) được sử dụng để chỉ định mục đích hoặc hành động mà một yêu cầu HTTP muốn thực hiện trên tài nguyên.

- Dưới đây là một số phương thức cơ bản trong HTTP:

1. `GET`: Sử dụng để lấy thông tin từ một tài nguyên đã cho. Yêu cầu GET không thay đổi dữ liệu trên máy chủ và chỉ trả về dữ liệu đã được yêu cầu.

2. `POST`: Sử dụng để gửi dữ liệu mới đến máy chủ để tạo một tài nguyên mới. Yêu cầu POST thường đi kèm với dữ liệu được gửi trong phần thân của yêu cầu.

3. `PUT`: Sử dụng để cập nhật hoặc tạo mới một tài nguyên với nội dung đã được cung cấp. Yêu cầu PUT thay đổi hoặc tạo mới tài nguyên theo đường dẫn được chỉ định.

4. `DELETE`: Sử dụng để xóa một tài nguyên đã cho. Yêu cầu DELETE xóa tài nguyên theo đường dẫn được chỉ định.

- Ngoài ra, còn có các phương thức khác như `OPTIONS`, `HEAD`, `PATCH`, `TRACE`, `CONNECT` được sử dụng cho các mục đích đặc biệt trong HTTP.

- Khi gửi một yêu cầu HTTP, phương thức được xác định trong phần đầu yêu cầu gọi là "phương thức yêu cầu" (`request method`). Máy chủ nhận yêu cầu và xử lý tương ứng với phương thức đó để trả về kết quả hoặc thực hiện hành động tương ứng.

- Các phương thức HTTP cung cấp khả năng thực hiện các hành động khác nhau trên tài nguyên, cho phép giao tiếp và thay đổi dữ liệu trên web.

## ❌❌ Lưu ý: GET khác với POST trong HTTP là gì ? cái nào khi sử dụng thì thông tin hiện lên đường dẫn url ? cài nào không hiện thông tin lên url ?

- Trong HTTP, `GET` và `POST` là hai phương thức khác nhau được sử dụng để truyền tải dữ liệu giữa máy chủ và trình duyệt web.

- Phương thức `GET` được sử dụng để yêu cầu tài nguyên từ máy chủ web và trả về nội dung của tài nguyên đó. Khi sử dụng phương thức `GET`, thông tin yêu cầu của bạn được đính kèm vào URL dưới dạng `query string`, do đó thông tin sẽ hiển thị trên đường dẫn URL.

- Phương thức `POST` được sử dụng để gửi dữ liệu đến máy chủ web (`client gửi đến server`) để thực hiện một hành động nhất định. Thông tin yêu cầu của bạn được gửi trong phần `body` của yêu cầu HTTP và không hiển thị trên đường dẫn URL.

- Vì vậy, khi sử dụng phương thức `GET`, thông tin yêu cầu sẽ được hiển thị trên URL, trong khi đó khi sử dụng phương thức `POST`, thông tin sẽ không được hiển thị trên URL. Phương thức `POST` thường được sử dụng khi bạn cần gửi dữ liệu lớn hoặc dữ liệu nhạy cảm, và không muốn thông tin đó được hiển thị trên đường dẫn URL.

## Hãy định nghĩa hàm useMutation trong React Query ?

- Trong React Query, hàm `useMutation` nhận vào một hàm thực thi thao tác thay đổi dữ liệu, thường là một hàm gọi API để tạo, cập nhật hoặc xóa dữ liệu. Hàm này sẽ được gọi khi bạn muốn thực hiện một thao tác thay đổi dữ liệu.

- Cú pháp của `useMutation` như sau:

```jsx
const mutation = useMutation(mutationFunction, options)
```

- `mutationFunction` là một hàm mà khi gọi, nó sẽ thực hiện thao tác thay đổi dữ liệu. Hàm này thường gọi API để gửi yêu cầu tới máy chủ.
- `options` (tùy chọn) là một đối tượng chứa các tuỳ chọn để tùy chỉnh hành vi của `useMutation`. Đây là một đối tượng có thể bao gồm các thuộc tính như `onSuccess`, `onError`, `onSettled`, `onMutate`, `retry`, v.v.

- Khi sử dụng `useMutation`, nó sẽ trả về một đối tượng `mutation` với các thuộc tính và phương thức hữu ích để quản lý trạng thái và kết quả của thao tác thay đổi dữ liệu. Một số thuộc tính quan trọng của đối tượng `mutation` bao gồm:

  - `mutate`: Một hàm được sử dụng để kích hoạt thực thi thao tác thay đổi dữ liệu.
  - `isLoading`: Một giá trị `boolean` cho biết liệu thao tác đang được thực hiện hay không.
  - `isError`: Một giá trị `boolean` cho biết liệu có xảy ra lỗi trong quá trình thực hiện thao tác hay không.
  - `isSuccess`: Một giá trị `boolean` cho biết liệu thao tác đã thành công hay không.
  - `data`: Dữ liệu trả về từ thao tác thay đổi dữ liệu (nếu thành công).

- Qua đó, `useMutation` cho phép bạn dễ dàng quản lý trạng thái và kết quả của thao tác thay đổi dữ liệu trong React Query.

## Thuộc tính trong React Query bao gồm những gì ?

- Trong React Query, khi sử dụng `useMutation`, thuộc tính được truyền vào trong đối tượng `mutationFunction` là một đối tượng JSON (JavaScript Object Notation) chứa các cặp khóa-giá trị (key-value) của dữ liệu bạn muốn thay đổi. Ví dụ:

```jsx
const mutation = useMutation(createUser, options)
```

- Trong ví dụ trên, `createUser` là một hàm thực hiện thao tác tạo người dùng (hoặc thay đổi dữ liệu khác). Đối tượng JSON chứa dữ liệu cần thay đổi sẽ được truyền vào hàm này.

- Ví dụ, nếu bạn muốn tạo một người dùng mới với tên là "David", tuổi là 25, bạn có thể truyền một đối tượng JSON như sau:

```jsx
const newUser = {
  name: 'David',
  age: 25
  // các thuộc tính khác nếu cần
}

const mutation = useMutation(() => createUser(newUser), options)
```

- Trong đó, `newUser` là một đối tượng JSON chứa các cặp khóa-giá trị. Mỗi khóa đại diện cho một thuộc tính (ví dụ: 'name', 'age') và giá trị tương ứng là dữ liệu bạn muốn thay đổi (ví dụ: 'David', 25).

- Khi thực hiện thao tác thay đổi dữ liệu bằng cách gọi `mutation.mutate()`, đối tượng `mutationFunction` (trong ví dụ là `createUser`) sẽ được gọi và nhận đối tượng JSON này làm đối số để thực hiện thao tác thay đổi dữ liệu.

## Ví dụ trên là truyền 1 dữ liệu tĩnh rồi. Hãy cho ví dụ khác truyền vào một đối tượng động ?

- Tất nhiên! Dưới đây là một ví dụ khác, truyền vào một đối tượng động khi sử dụng `useMutation` trong React Query:

- Gồm có 2 đoạn code: (chý đọc từ trên xuống dưới)

```jsx
const mutation = useMutation(updateUser, {
  onSuccess: () => {
    // Xử lý thành công sau khi mutation hoàn thành
    console.log('Cập nhật người dùng thành công')
  },
  onError: (error) => {
    // Xử lý khi có lỗi xảy ra trong quá trình mutation
    console.error('Lỗi khi cập nhật người dùng:', error)
  }
})

const handleUpdateUser = () => {
  const updatedUser = {
    id: 1,
    name: 'John Doe',
    age: 30
    // các thuộc tính khác nếu cần
  }

  mutation.mutate(updatedUser)
}
```

- Trong ví dụ trên, chúng ta định nghĩa một hàm `handleUpdateUser` để thực hiện việc cập nhật người dùng. Tham số đầu tiên là đối tượng `updatedUser` chứa thông tin về người dùng muốn cập nhật, bao gồm `id`, `name`, `age` và các thuộc tính khác (nếu cần). Tham số thứ hai đó là option của hàm `useMutation`. Tham số option này có thể tuỳ chỉnh hành vi và xử lý sau khi `mutation` hoàn thành hoặc xảy ra lỗi.

- Khi gọi `mutation.mutate(updatedUser)`, đối tượng `updatedUser` sẽ được truyền vào `mutationFunction` (trong ví dụ là `updateUser`) để thực hiện thao tác cập nhật dữ liệu.

- Trong `mutationFunction` (`updateUser`), bạn có thể sử dụng thông tin từ đối tượng `updatedUser` để thực hiện các thao tác cần thiết, ví dụ:

```jsx
const updateUser = async (user) => {
  try {
    const response = await axios.put(`/api/users/${user.id}`, user)
    return response.data
  } catch (error) {
    throw new Error('Failed to update user')
  }
}
```

- Trong ví dụ trên, chúng ta sử dụng `axios` để gửi yêu cầu PUT đến API với đường dẫn `/api/users/{userId}` để cập nhật thông tin người dùng. Đối tượng `user` được truyền vào yêu cầu PUT chính là `updatedUser` mà chúng ta đã truyền vào `mutation.mutate()`.

- Hy vọng rằng ví dụ này giúp bạn hiểu cách truyền một đối tượng động khi sử dụng `useMutation` trong React Query.

## Giải thích 2 đoạn code ở trên:

✅ Đoạn code thứ 1 (giải thích):

```jsx
const mutation = useMutation(updateUser, {
  onSuccess: () => {
    // Xử lý thành công sau khi mutation hoàn thành
    console.log('Cập nhật người dùng thành công')
  },
  onError: (error) => {
    // Xử lý khi có lỗi xảy ra trong quá trình mutation
    console.error('Lỗi khi cập nhật người dùng:', error)
  }
})

const handleUpdateUser = () => {
  const updatedUser = {
    id: 1,
    name: 'John Doe',
    age: 30
    // các thuộc tính khác nếu cần
  }

  mutation.mutate(updatedUser)
}
```

- Trong đoạn code trên, chúng ta sử dụng `useMutation` từ React Query để tạo một `mutation` (thay đổi dữ liệu) mới.

- `useMutation` nhận vào hai tham số chính: `updateUser` và `options`.

  - `updateUser` là một hàm được định nghĩa để thực hiện việc cập nhật thông tin người dùng. Đối tượng `updatedUser` được truyền vào hàm này là đối tượng chứa thông tin cập nhật, bao gồm `id`, `name`, `age` và các thuộc tính khác (nếu có).

  - `options` là một đối tượng chứa các tuỳ chọn cho `mutation`. Trong đoạn code trên, bạn có thể thêm các tuỳ chọn như `onSuccess`, `onError`, hoặc `onSettled` để xử lý các trạng thái hoặc hành động liên quan đến `mutation`.

  - Trong ví dụ trên, chúng ta đã thêm một đối tượng `options` vào hàm `useMutation`. Trong options, chúng ta đã sử dụng hai thuộc tính:

  - `onSuccess`: Đây là một hàm được gọi khi mutation hoàn thành thành công. Trong ví dụ này, chúng ta chỉ đơn giản ghi thông báo "Cập nhật người dùng thành công" vào console. Bạn có thể thay đổi hoặc mở rộng hành động tương ứng với thành công của mutation.

  - `onError`: Đây là một hàm được gọi khi có lỗi xảy ra trong quá trình mutation. Trong ví dụ này, chúng ta ghi thông báo lỗi và hiển thị nội dung lỗi trong console. Bạn có thể thay đổi hoặc xử lý các tình huống lỗi khác tùy theo yêu cầu của bạn.

  - Với việc thêm options vào `useMutation`, bạn có thể tuỳ chỉnh hành vi và xử lý sau khi mutation hoàn thành hoặc xảy ra lỗi.

- Tiếp theo, chúng ta định nghĩa hàm `handleUpdateUser` để thực hiện việc cập nhật người dùng. Trong hàm này, chúng ta khai báo một đối tượng `updatedUser` với các thuộc tính cần cập nhật. Trong ví dụ này, chúng ta cập nhật người dùng có `id` là 1, `name` là 'John Doe', và `age` là 30. Bạn có thể thêm hoặc chỉnh sửa các thuộc tính khác theo nhu cầu.

- Cuối cùng, chúng ta gọi `mutation.mutate(updatedUser)` để kích hoạt mutation và thực hiện việc cập nhật người dùng. Đối tượng `updatedUser` sẽ được truyền vào hàm `updateUser` để thực hiện thao tác cập nhật thông tin người dùng.

- Sau khi mutation hoàn thành, React Query sẽ tự động quản lý trạng thái và cung cấp các giá trị như `isLoading`, `isError`, `isSuccess` để bạn có thể xử lý kết quả hoặc hiển thị giao diện tương ứng.

✅ Đoạn code thứ 2 (giải thích):

```jsx
const updateUser = async (user) => {
  try {
    const response = await axios.put(`/api/users/${user.id}`, user)
    return response.data
  } catch (error) {
    throw new Error('Failed to update user')
  }
}
```

- Trong đoạn code trên, chúng ta định nghĩa một hàm `updateUser` để thực hiện việc cập nhật thông tin người dùng bằng cách gửi một yêu cầu PUT đến endpoint `/api/users/{user.id}` trên máy chủ.

  - Đầu tiên, chúng ta sử dụng thư viện Axios để gửi yêu cầu PUT bằng cách sử dụng phương thức `axios.put()`. Đối số đầu tiên của phương thức này là URL endpoint, trong đó chúng ta sử dụng `user.id` để xác định người dùng cần cập nhật. Đối số thứ hai là `user`, đại diện cho đối tượng chứa thông tin cần cập nhật (trong ví dụ này là `updatedUser`).

  - Sau khi gửi yêu cầu PUT, chúng ta chờ đợi phản hồi từ máy chủ bằng cách sử dụng từ khóa `await`. Phản hồi được lưu trữ trong biến `response`.
  - Nếu yêu cầu được xử lý thành công và nhận được phản hồi từ máy chủ, chúng ta trả về dữ liệu từ phản hồi bằng cách sử dụng `response.data`.
  - Trong trường hợp xảy ra lỗi trong quá trình gửi yêu cầu hoặc nhận phản hồi, một ngoại lệ (exception) sẽ được ném ra bằng cách sử dụng từ khóa `throw new Error()`. Trong đoạn code trên, chúng ta ném ra một ngoại lệ với thông báo `'Failed to update user'`.

- Khi sử dụng `useMutation` và truyền hàm `updateUser` vào, React Query sẽ quản lý quá trình `mutation`, xử lý trạng thái và cung cấp các giá trị như `isLoading`, `isError`, `isSuccess` và `data` để xử lý kết quả hoặc hiển thị giao diện tương ứng.

## Nếu useQuery dùng để GET thì useMutation dùng để POST, PUT, DELETE ? Hãy nêu sự khác nhau ?

- Đúng, trong React Query, `useMutation` được sử dụng để thực hiện các thao tác POST, PUT và DELETE (thay đổi dữ liệu) liên quan đến việc gửi yêu cầu tới server. Dưới đây là sự khác nhau chính giữa `useQuery` và `useMutation`:

1. `Tác động lên dữ liệu:` `useQuery` chỉ được sử dụng để truy vấn dữ liệu (GET) từ server, trong khi `useMutation` được sử dụng để thực hiện các thao tác thay đổi dữ liệu như tạo mới (POST), cập nhật (PUT) và xóa (DELETE) dữ liệu trên server.

2. `Hành động:` `useQuery` tạo ra một `instance` truy vấn dữ liệu, giúp ta lấy dữ liệu từ server và lưu trữ vào cache. Trong khi đó, `useMutation` tạo ra một `instance` thực hiện thao tác thay đổi dữ liệu, giúp ta gửi yêu cầu thay đổi dữ liệu tới server và xử lý kết quả trả về.

3. `Tính năng cung cấp:` `useQuery` cung cấp các tính năng như caching, tự động fetch lại dữ liệu khi cần thiết, background fetching, và nhiều tùy chọn khác liên quan đến truy vấn dữ liệu. Trong khi đó, `useMutation` cung cấp các tính năng như tự động làm mới cache sau khi thao tác thay đổi dữ liệu thành công, xử lý lỗi và thành công, và nhiều tùy chọn khác liên quan đến thao tác thay đổi dữ liệu.

4. `Callback functions:` Trong `useMutation`, ta có thể định nghĩa các callback functions như `onSuccess`, `onError`, `onSettled` để xử lý kết quả và các trạng thái của thao tác thay đổi dữ liệu.

- Tóm lại, `useMutation` là một hook trong React Query được sử dụng để thực hiện các thao tác thay đổi dữ liệu (POST, PUT, DELETE) và cung cấp các tính năng và tùy chọn liên quan đến thao tác thay đổi dữ liệu.

- Tiếp tục với sự khác nhau giữa `useQuery` và `useMutation` trong React Query:

1. `Tham số đầu vào:` Khi sử dụng `useQuery`, ta truyền `queryKey` và `queryFn` để xác định key của truy vấn và hàm để lấy dữ liệu từ server. Trong khi đó, khi sử dụng `useMutation`, ta truyền `mutationFn` để xác định hàm thực hiện thao tác thay đổi dữ liệu.

2. `Trạng thái và kết quả:` `useQuery` cung cấp các trạng thái như `isLoading`, `isError`, `isSuccess` để xác định trạng thái của truy vấn dữ liệu và `data` để lưu trữ kết quả trả về từ server. Trong khi đó, `useMutation` cung cấp các trạng thái như `isLoading`, `isError`, `isSuccess` để xác định trạng thái của thao tác thay đổi dữ liệu và không trả về kết quả từ server.

- Khi sử dụng hook `useQuery`, bạn có thể thực hiện truy vấn dữ liệu từ máy chủ.
- Khi sử dụng hook `useMutation`, bạn có thể thực hiện các thao tác thay đổi dữ liệu, chẳng hạn như tạo, cập nhật hoặc xóa dữ liệu trên máy chủ.

3. `Cập nhật cache:` Khi sử dụng `useQuery`, React Query tự động cập nhật cache khi có dữ liệu mới từ server hoặc khi cache hết hạn. Trong khi đó, khi sử dụng `useMutation`, ta cần xử lý cập nhật cache thủ công sau khi thao tác thay đổi dữ liệu thành công.

4. `Tối ưu hóa:` `useQuery` cung cấp các tính năng tối ưu hóa như `caching`, `background fetching` và `refetching` tự động dựa trên các tương tác của người dùng. Trong khi đó, `useMutation` tập trung vào việc thực hiện thao tác thay đổi dữ liệu một cách đáng tin cậy và xử lý kết quả tương ứng.

- Tóm lại, `useQuery` và `useMutation` là hai hook trong React Query được sử dụng cho mục đích khác nhau. `useQuery` được sử dụng để truy vấn dữ liệu (GET) từ server và cung cấp các tính năng liên quan đến truy vấn dữ liệu. `useMutation` được sử dụng để thực hiện các thao tác thay đổi dữ liệu (POST, PUT, DELETE) và cung cấp các tính năng liên quan đến thao tác thay đổi dữ liệu.

## Thêm student với useMutation trong React Query ?

- Để thêm một sinh viên mới sử dụng `useMutation` trong React Query, bạn có thể thực hiện các bước sau:

1. Định nghĩa hàm thực hiện thao tác thêm sinh viên (`POST`) lên server:

```jsx
const addStudent = async (newStudent) => {
  const response = await fetch('api/students', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(newStudent)
  })

  if (!response.ok) {
    throw new Error('Failed to add student')
  }

  const data = await response.json()
  return data
}
```

2. Sử dụng `useMutation` để tạo một mutation hook để thực hiện thao tác thêm sinh viên:

```jsx
import { useMutation } from 'react-query'

const AddStudentForm = () => {
  const mutation = useMutation(addStudent)

  const handleSubmit = (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const newStudent = Object.fromEntries(formData.entries())
    mutation.mutate(newStudent)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type='text' name='name' placeholder='Name' required />
      <input type='text' name='age' placeholder='Age' required />
      <button type='submit' disabled={mutation.isLoading}>
        {mutation.isLoading ? 'Adding...' : 'Add Student'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>Student added successfully!</div>}
    </form>
  )
}
```

- Trong ví dụ trên, `mutation` là một object được trả về từ hook `useMutation`. Bạn có thể sử dụng `mutation.mutate` để kích hoạt thao tác thêm sinh viên khi form được submit. `mutation.isLoading`, `mutation.isError`, và `mutation.isSuccess` là các trạng thái để xử lý giao diện khi thao tác đang diễn ra, gặp lỗi, hoặc thành công.

- Lưu ý rằng, việc xử lý cập nhật cache sau khi thêm sinh viên thành công cần phụ thuộc vào cấu hình và quyết định của bạn. Bạn có thể sử dụng các phương thức như `queryClient.invalidateQueries` để cập nhật cache cho danh sách sinh viên hoặc trang chi tiết sinh viên.

- Đây chỉ là một ví dụ cơ bản về việc sử dụng `useMutation` để thêm sinh viên. Bạn có thể tùy chỉnh và bổ sung thêm theo nhu cầu của ứng dụng của mình.

## Giải thích chi tiết đoạn code trên:

```jsx
const addStudent = async (newStudent) => {
  const response = await fetch('api/students', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(newStudent)
  })

  if (!response.ok) {
    throw new Error('Failed to add student')
  }

  const data = await response.json()
  return data
}
```

- Đoạn code trên định nghĩa một hàm `addStudent` để thực hiện thao tác thêm sinh viên mới (POST) lên server thông qua API endpoint `'api/students`'.

- Hàm `addStudent` sử dụng `fetch` để gửi một request POST đến endpoint `'api/students'` với các thông tin của sinh viên mới được đưa vào trong body của request dưới dạng JSON. Để thực hiện điều này, `fetch` được gọi với các tham số như sau:

- `method: 'POST':` Thuộc tính `method` xác định phương thức HTTP được sử dụng trong yêu cầu. Trong trường hợp này, phương thức được sử dụng là POST. Phương thức POST được sử dụng để gửi dữ liệu từ client lên máy chủ để tạo hoặc cập nhật tài nguyên.

- `headers: {'Content-Type': 'application/json'}:` Thuộc tính `headers` định nghĩa các tiêu đề (headers) của yêu cầu HTTP. Trong trường hợp này, đoạn mã chỉ định một tiêu đề `'Content-Type'` với giá trị `'application/json'`. Tiêu đề này cho biết rằng dữ liệu trong yêu cầu được gửi dưới dạng JSON. Điều này giúp máy chủ hiểu cách xử lý và phân tích nội dung yêu cầu.

- `body: JSON.stringify(newStudent):` Thuộc tính `body` định nghĩa nội dung của yêu cầu HTTP. Trong trường hợp này, `JSON.stringify(newStudent)` được sử dụng để chuyển đổi đối tượng (object) `newStudent` thành chuỗi JSON (JSON String). Chuỗi JSON này sau đó được gán cho thuộc tính `body`. Điều này đảm bảo rằng dữ liệu của `newStudent` được gửi đi dưới dạng chuỗi JSON trong yêu cầu POST.

- Khi yêu cầu HTTP POST này được gửi đi, nó sẽ chứa một tiêu đề `'Content-Type': 'application/json'` để chỉ định kiểu nội dung là JSON và một phần body chứa dữ liệu của `newStudent` đã được chuyển đổi thành chuỗi JSON.

- `if (!response.ok):` Đây là một câu điều kiện kiểm tra xem phản hồi từ máy chủ có thành công hay không. Phản hồi được coi là thành công nếu trạng thái HTTP là trong khoảng từ 200 đến 299 (bao gồm cả 200 và 299). Điều kiện `!response.ok` kiểm tra xem trạng thái HTTP có nằm ngoài khoảng thành công hay không.

- `throw new Error('Failed to add student'):` Nếu phản hồi không thành công, một ngoại lệ (exception) được ném bằng cách sử dụng `throw`. Trong trường hợp này, một đối tượng lỗi mới được tạo với thông báo `'Failed to add student'`. Ngoại lệ này sẽ được truyền cho phần xử lý lỗi bên ngoài hàm hiện tại để xử lý tiếp theo.

- `const data = await response.json():` Nếu phản hồi thành công, dữ liệu trong phản hồi được đọc và chuyển đổi từ định dạng JSON sang đối tượng JavaScript bằng cách sử dụng phương thức `response.json()`. Kết quả của phương thức này là một lời hứa (promise) được giải quyết (resolved) khi dữ liệu JSON đã được chuyển đổi thành đối tượng JavaScript.

- `return data:` Kết quả của hàm là đối tượng dữ liệu (`data`). Nếu mọi thứ thành công, dữ liệu này sẽ được trả về cho người gọi hàm để sử dụng tiếp.

- Tóm lại, đoạn mã trên kiểm tra và xử lý phản hồi từ máy chủ sau một yêu cầu HTTP. Nếu phản hồi thành công, nó trả về dữ liệu từ phản hồi dưới dạng đối tượng JavaScript. Nếu phản hồi không thành công, nó ném một ngoại lệ để xử lý lỗi.

## ❌❌ Lưu ý: Tại sao không dùng `response.parse()` mà lại sử dụng `response.json()`. Trong khi 2 dạng đó đều trả về dạng đối tượng jsvascript ?

- Thật đúng là có một sự khác biệt giữa `response.parse()` và `response.json()`, và trong hầu hết các trường hợp, chúng ta sẽ sử dụng `response.json()` để chuyển đổi phản hồi từ JSON sang đối tượng JavaScript. Dưới đây là sự khác biệt chính giữa hai phương thức này:

1. `response.parse():` Phương thức `parse()` không tồn tại trong đối tượng `response` của một yêu cầu HTTP. Thay vào đó, phương thức `parse()` là một phương thức của đối tượng `JSON` trong JavaScript. Nó được sử dụng để chuyển đổi một chuỗi JSON thành một đối tượng JavaScript.

2. `response.json():` Phương thức `json()` là một phương thức của đối tượng `response` trong JavaScript. Khi gọi phương thức này trên đối tượng `response`, nó trả về một lời hứa (promise) mà khi giải quyết (resolved), nó trả về dữ liệu JSON được chuyển đổi thành đối tượng JavaScript.

- Sự khác biệt chính giữa hai phương thức này là `response.json()` không chỉ chuyển đổi JSON thành đối tượng JavaScript, mà nó cũng xử lý việc đọc và xử lý dữ liệu từ phản hồi HTTP. Nó tự động đọc và chuyển đổi phản hồi thành dữ liệu JSON và trả về một hứa chứa đối tượng JavaScript đã chuyển đổi.

- Vì vậy, khi làm việc với phản hồi từ một yêu cầu HTTP, chúng ta sử dụng `response.json()` để thuận tiện đọc và chuyển đổi dữ liệu JSON thành đối tượng JavaScript.

```jsx
import { useMutation } from 'react-query'

const AddStudentForm = () => {
  const mutation = useMutation(addStudent)

  const handleSubmit = (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const newStudent = Object.fromEntries(formData.entries())
    mutation.mutate(newStudent)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type='text' name='name' placeholder='Name' required />
      <input type='text' name='age' placeholder='Age' required />
      <button type='submit' disabled={mutation.isLoading}>
        {mutation.isLoading ? 'Adding...' : 'Add Student'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>Student added successfully!</div>}
    </form>
  )
}
```

- Đoạn code trên định nghĩa một component `AddStudentForm` sử dụng `useMutation` từ React Query để thực hiện thao tác thêm sinh viên mới.

- Trong component `AddStudentForm`, hàm `useMutation` được gọi với đối số là hàm `addStudent` (đã được định nghĩa trước đó) để tạo ra một đối tượng `mutation`. Đối tượng `mutation` chứa các phương thức và trạng thái liên quan đến việc thực hiện mutation (POST) và xử lý kết quả.

- Trong hàm `handleSubmit`, khi người dùng gửi form bằng cách nhấn nút `submit`, sự kiện `submit` được kích hoạt. Hàm `handleSubmit` được gọi và truyền vào đối tượng sự kiện event như tham số.

- Để tránh việc trình duyệt gửi request và refresh trang, hàm `event.preventDefault()` được gọi để ngăn chặn hành vi mặc định của form.

- Sau đó, thông tin từ form được lấy bằng cách tạo một đối tượng `formData` từ `event.target`, đại diện cho form được gửi đi. `FormData` là một đối tượng tích hợp sẵn trong JavaScript cho phép truy cập và xử lý dữ liệu form.

- Tiếp theo, `formData.entries()` trả về một iterator chứa tất cả cặp khóa-giá trị (key-value) trong form data. `Object.fromEntries()` được sử dụng để chuyển đổi iterator này thành một đối tượng JSON `newStudent`, trong đó khóa là tên của các trường form và giá trị là giá trị đã nhập.

- Cuối cùng, `mutation.mutate(newStudent)` được gọi để kích hoạt quá trình mutation (POST) với đối tượng `newStudent` là dữ liệu cần thêm. Quá trình này sẽ được xử lý bởi React Query, bao gồm gửi request lên server, xử lý kết quả và cập nhật cache nếu cần.

- Đoạn code trên giúp kết nối form và việc thực hiện thao tác thêm sinh viên mới thông qua `useMutation`, và cho phép xử lý các tương tác với form và quá trình mutation một cách dễ dàng trong React.

## ❌❌ Hãy định nghĩa phương thức entries() trong JavaScript là gì ?

- Phương thức `entries()` là một phương thức của đối tượng `Object` trong JavaScript. Nó được sử dụng để trả về một mảng chứa các cặp khóa-giá trị (`key-value`) của một đối tượng.

- Khi áp dụng phương thức `entries()` lên một đối tượng, nó sẽ tạo ra một mảng các cặp khóa-giá trị, trong đó mỗi cặp bao gồm một khóa (key) và giá trị (value) của thuộc tính trong đối tượng.

- Ví dụ, xét một đối tượng `person` như sau:

```jsx
const person = {
  name: 'John',
  age: 30,
  occupation: 'Engineer'
}
```

- Khi áp dụng `Object.entries(person)`, kết quả sẽ là một mảng chứa các cặp khóa-giá trị như sau:

```jsx
;[
  ['name', 'John'],
  ['age', 30],
  ['occupation', 'Engineer']
]
```

- Mỗi phần tử trong mảng là một mảng con chứa một cặp khóa-giá trị, trong đó phần tử đầu tiên là khóa và phần tử thứ hai là giá trị tương ứng.

- Phương thức `entries()` rất hữu ích khi bạn muốn lặp qua các thuộc tính của một đối tượng và thực hiện các thao tác trên từng cặp khóa-giá trị trong đối tượng đó.

## ❌❌ Ví dụ về entries() trong JavaScript ?

- Để minh họa cách sử dụng phương thức `entries()`, hãy xem xét ví dụ sau:

```jsx
const person = {
  name: 'John',
  age: 30,
  occupation: 'Engineer'
}

// Sử dụng phương thức entries() để lặp qua các cặp khóa-giá trị trong đối tượng person
for (const [key, value] of Object.entries(person)) {
  console.log(`${key}: ${value}`)
}
```

- Đầu tiên, chúng ta có một đối tượng `person` đại diện cho thông tin về một người. Chúng ta muốn lặp qua các thuộc tính của đối tượng này và hiển thị cặp khóa-giá trị tương ứng.

- Bằng cách sử dụng phương thức `Object.entries(person)`, chúng ta chuyển đổi đối tượng `person` thành một mảng chứa các cặp khóa-giá trị.

- Sau đó, chúng ta sử dụng một vòng lặp `for...of` để lặp qua mảng các cặp khóa-giá trị. Trong mỗi lần lặp, chúng ta gán khóa và giá trị tương ứng cho các biến `key` và `value`. Sau đó, chúng ta hiển thị cặp khóa-giá trị bằng cách sử dụng `console.log()`.

- Kết quả của đoạn mã trên sẽ là:

```jsx
name: John
age: 30
occupation: Engineer
```

- Mỗi dòng đại diện cho một cặp khóa-giá trị trong đối tượng `person`, trong đó `key` là khóa (ví dụ: 'name', 'age', 'occupation') và `value` là giá trị tương ứng (ví dụ: 'John', 30, 'Engineer').

- Điều này cho thấy chúng ta đã lặp qua các thuộc tính của đối tượng `person` và hiển thị cặp khóa-giá trị tương ứng.

## Xử lý lỗi 422 khi submit form bị lỗi trong React Query ?

- Để xử lý lỗi 422 khi submit form bị lỗi trong React Query, bạn có thể sử dụng thuộc tính `onError` của đối tượng mutation trả về bởi `useMutation`. Dưới đây là một ví dụ về cách xử lý lỗi 422:

```jsx
import { useMutation } from 'react-query'

const AddStudentForm = () => {
  const mutation = useMutation(addStudent, {
    onError: (error) => {
      if (error.response?.status === 422) {
        // Xử lý lỗi 422 ở đây
        // Ví dụ: Hiển thị thông báo lỗi hoặc cập nhật trạng thái lỗi
      }
    }
  })

  const handleSubmit = (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const newStudent = Object.fromEntries(formData.entries())
    mutation.mutate(newStudent)
  }

  // ...
}
```

## Reset error và data trong React Query ?

## Reset formState với mutationAsync trong React Query ?

## Đây là Docs của Được Dev:

Nếu useQuery dùng để GET thì useMutation dùng để POST, PUT, DELETE. Video này tiếp nối video lần trước chúng ta sẽ thực hiện chức năng thêm học sinh 🎉

💓Kiến thức các bạn sẽ được học trong video này:

🎉 Cách phân trang và tối ưu UX với React Query
🎉 Những state quan trọng trong React Query
🎉 Cơ chế caching của React Query

🕰️Nội dung chính

00:00 - add student với useMutation
28:38 - Xử lý lỗi 422 khi submit form bị lỗi
48:20 - reset error và data
50:45 - reset formState với mutationAsync

```

```
