## Đây là Docs tự research:

## Nếu useQuery dùng để GET thì useMutation dùng để POST, PUT, DELETE ? Hãy nêu sự khác nhau ?

- Đúng, trong React Query, `useMutation` được sử dụng để thực hiện các thao tác POST, PUT và DELETE (thay đổi dữ liệu) liên quan đến việc gửi yêu cầu tới server. Dưới đây là sự khác nhau chính giữa `useQuery` và `useMutation`:

1. `Tác động lên dữ liệu:` `useQuery` chỉ được sử dụng để truy vấn dữ liệu (GET) từ server, trong khi `useMutation` được sử dụng để thực hiện các thao tác thay đổi dữ liệu như tạo mới (POST), cập nhật (PUT) và xóa (DELETE) dữ liệu trên server.

2. `Hành động:` `useQuery` tạo ra một `instance` truy vấn dữ liệu, giúp ta lấy dữ liệu từ server và lưu trữ vào cache. Trong khi đó, `useMutation` tạo ra một `instance` thực hiện thao tác thay đổi dữ liệu, giúp ta gửi yêu cầu thay đổi dữ liệu tới server và xử lý kết quả trả về.

3. `Tính năng cung cấp:` `useQuery` cung cấp các tính năng như caching, tự động fetch lại dữ liệu khi cần thiết, background fetching, và nhiều tùy chọn khác liên quan đến truy vấn dữ liệu. Trong khi đó, `useMutation` cung cấp các tính năng như tự động làm mới cache sau khi thao tác thay đổi dữ liệu thành công, xử lý lỗi và thành công, và nhiều tùy chọn khác liên quan đến thao tác thay đổi dữ liệu.

4. `Callback functions:` Trong `useMutation`, ta có thể định nghĩa các callback functions như `onSuccess`, `onError`, `onSettled` để xử lý kết quả và các trạng thái của thao tác thay đổi dữ liệu.

- Tóm lại, `useMutation` là một hook trong React Query được sử dụng để thực hiện các thao tác thay đổi dữ liệu (POST, PUT, DELETE) và cung cấp các tính năng và tùy chọn liên quan đến thao tác thay đổi dữ liệu.

- Tiếp tục với sự khác nhau giữa `useQuery` và `useMutation` trong React Query:

1. `Tham số đầu vào:` Khi sử dụng `useQuery`, ta truyền `queryKey` và `queryFn` để xác định key của truy vấn và hàm để lấy dữ liệu từ server. Trong khi đó, khi sử dụng `useMutation`, ta truyền `mutationFn` để xác định hàm thực hiện thao tác thay đổi dữ liệu.

2. `Trạng thái và kết quả:` `useQuery` cung cấp các trạng thái như `isLoading`, `isError`, `isSuccess` để xác định trạng thái của truy vấn dữ liệu và `data` để lưu trữ kết quả trả về từ server. Trong khi đó, `useMutation` cung cấp các trạng thái như `isLoading`, `isError`, `isSuccess` để xác định trạng thái của thao tác thay đổi dữ liệu và không trả về kết quả từ server.

- Khi sử dụng hook `useQuery`, bạn có thể thực hiện truy vấn dữ liệu từ máy chủ.
- Khi sử dụng hook `useMutation`, bạn có thể thực hiện các thao tác thay đổi dữ liệu, chẳng hạn như tạo, cập nhật hoặc xóa dữ liệu trên máy chủ.

3. `Cập nhật cache:` Khi sử dụng `useQuery`, React Query tự động cập nhật cache khi có dữ liệu mới từ server hoặc khi cache hết hạn. Trong khi đó, khi sử dụng `useMutation`, ta cần xử lý cập nhật cache thủ công sau khi thao tác thay đổi dữ liệu thành công.

4. `Tối ưu hóa:` `useQuery` cung cấp các tính năng tối ưu hóa như `caching`, `background fetching` và `refetching` tự động dựa trên các tương tác của người dùng. Trong khi đó, `useMutation` tập trung vào việc thực hiện thao tác thay đổi dữ liệu một cách đáng tin cậy và xử lý kết quả tương ứng.

- Tóm lại, `useQuery` và `useMutation` là hai hook trong React Query được sử dụng cho mục đích khác nhau. `useQuery` được sử dụng để truy vấn dữ liệu (GET) từ server và cung cấp các tính năng liên quan đến truy vấn dữ liệu. `useMutation` được sử dụng để thực hiện các thao tác thay đổi dữ liệu (POST, PUT, DELETE) và cung cấp các tính năng liên quan đến thao tác thay đổi dữ liệu.

## Thêm student với useMutation trong React Query ?

- Để thêm một sinh viên mới sử dụng `useMutation` trong React Query, bạn có thể thực hiện các bước sau:

1. Định nghĩa hàm thực hiện thao tác thêm sinh viên (`POST`) lên server:

```jsx
const addStudent = async (newStudent) => {
  const response = await fetch('api/students', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(newStudent)
  })

  if (!response.ok) {
    throw new Error('Failed to add student')
  }

  const data = await response.json()
  return data
}
```

2. Sử dụng `useMutation` để tạo một mutation hook để thực hiện thao tác thêm sinh viên:

```jsx
import { useMutation } from 'react-query'

const AddStudentForm = () => {
  const mutation = useMutation(addStudent)

  const handleSubmit = (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const newStudent = Object.fromEntries(formData.entries())
    mutation.mutate(newStudent)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type='text' name='name' placeholder='Name' required />
      <input type='text' name='age' placeholder='Age' required />
      <button type='submit' disabled={mutation.isLoading}>
        {mutation.isLoading ? 'Adding...' : 'Add Student'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>Student added successfully!</div>}
    </form>
  )
}
```

- Trong ví dụ trên, `mutation` là một object được trả về từ hook `useMutation`. Bạn có thể sử dụng `mutation.mutate` để kích hoạt thao tác thêm sinh viên khi form được submit. `mutation.isLoading`, `mutation.isError`, và `mutation.isSuccess` là các trạng thái để xử lý giao diện khi thao tác đang diễn ra, gặp lỗi, hoặc thành công.

- Lưu ý rằng, việc xử lý cập nhật cache sau khi thêm sinh viên thành công cần phụ thuộc vào cấu hình và quyết định của bạn. Bạn có thể sử dụng các phương thức như `queryClient.invalidateQueries` để cập nhật cache cho danh sách sinh viên hoặc trang chi tiết sinh viên.

- Đây chỉ là một ví dụ cơ bản về việc sử dụng `useMutation` để thêm sinh viên. Bạn có thể tùy chỉnh và bổ sung thêm theo nhu cầu của ứng dụng của mình.

## Giải thích chi tiết đoạn code trên:

```jsx
const addStudent = async (newStudent) => {
  const response = await fetch('api/students', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(newStudent)
  })

  if (!response.ok) {
    throw new Error('Failed to add student')
  }

  const data = await response.json()
  return data
}
```

- Đoạn code trên định nghĩa một hàm `addStudent` để thực hiện thao tác thêm sinh viên mới (POST) lên server thông qua API endpoint `'api/students`'.

- Hàm `addStudent` sử dụng `fetch` để gửi một request POST đến endpoint `'api/students'` với các thông tin của sinh viên mới được đưa vào trong body của request dưới dạng JSON. Để thực hiện điều này, `fetch` được gọi với các tham số như sau:

- `method: 'POST':` Thuộc tính `method` xác định phương thức HTTP được sử dụng trong yêu cầu. Trong trường hợp này, phương thức được sử dụng là POST. Phương thức POST được sử dụng để gửi dữ liệu từ client lên máy chủ để tạo hoặc cập nhật tài nguyên.

- `headers: {'Content-Type': 'application/json'}:` Thuộc tính `headers` định nghĩa các tiêu đề (headers) của yêu cầu HTTP. Trong trường hợp này, đoạn mã chỉ định một tiêu đề `'Content-Type'` với giá trị `'application/json'`. Tiêu đề này cho biết rằng dữ liệu trong yêu cầu được gửi dưới dạng JSON. Điều này giúp máy chủ hiểu cách xử lý và phân tích nội dung yêu cầu.

- `body: JSON.stringify(newStudent):` Thuộc tính `body` định nghĩa nội dung của yêu cầu HTTP. Trong trường hợp này, `JSON.stringify(newStudent)` được sử dụng để chuyển đổi đối tượng (object) `newStudent` thành chuỗi JSON (JSON String). Chuỗi JSON này sau đó được gán cho thuộc tính `body`. Điều này đảm bảo rằng dữ liệu của `newStudent` được gửi đi dưới dạng chuỗi JSON trong yêu cầu POST.

- Khi yêu cầu HTTP POST này được gửi đi, nó sẽ chứa một tiêu đề `'Content-Type': 'application/json'` để chỉ định kiểu nội dung là JSON và một phần body chứa dữ liệu của `newStudent` đã được chuyển đổi thành chuỗi JSON.

- `if (!response.ok):` Đây là một câu điều kiện kiểm tra xem phản hồi từ máy chủ có thành công hay không. Phản hồi được coi là thành công nếu trạng thái HTTP là trong khoảng từ 200 đến 299 (bao gồm cả 200 và 299). Điều kiện `!response.ok` kiểm tra xem trạng thái HTTP có nằm ngoài khoảng thành công hay không.

- `throw new Error('Failed to add student'):` Nếu phản hồi không thành công, một ngoại lệ (exception) được ném bằng cách sử dụng `throw`. Trong trường hợp này, một đối tượng lỗi mới được tạo với thông báo `'Failed to add student'`. Ngoại lệ này sẽ được truyền cho phần xử lý lỗi bên ngoài hàm hiện tại để xử lý tiếp theo.

- `const data = await response.json():` Nếu phản hồi thành công, dữ liệu trong phản hồi được đọc và chuyển đổi từ định dạng JSON sang đối tượng JavaScript bằng cách sử dụng phương thức `response.json()`. Kết quả của phương thức này là một lời hứa (promise) được giải quyết (resolved) khi dữ liệu JSON đã được chuyển đổi thành đối tượng JavaScript.

- `return data:` Kết quả của hàm là đối tượng dữ liệu (`data`). Nếu mọi thứ thành công, dữ liệu này sẽ được trả về cho người gọi hàm để sử dụng tiếp.

- Tóm lại, đoạn mã trên kiểm tra và xử lý phản hồi từ máy chủ sau một yêu cầu HTTP. Nếu phản hồi thành công, nó trả về dữ liệu từ phản hồi dưới dạng đối tượng JavaScript. Nếu phản hồi không thành công, nó ném một ngoại lệ để xử lý lỗi.

## ❌❌ Lưu ý: Tại sao không dùng `response.parse()` mà lại sử dụng `response.json()`. Trong khi 2 dạng đó đều trả về dạng đối tượng jsvascript ?

- Thật đúng là có một sự khác biệt giữa `response.parse()` và `response.json()`, và trong hầu hết các trường hợp, chúng ta sẽ sử dụng `response.json()` để chuyển đổi phản hồi từ JSON sang đối tượng JavaScript. Dưới đây là sự khác biệt chính giữa hai phương thức này:

1. `response.parse():` Phương thức `parse()` không tồn tại trong đối tượng `response` của một yêu cầu HTTP. Thay vào đó, phương thức `parse()` là một phương thức của đối tượng `JSON` trong JavaScript. Nó được sử dụng để chuyển đổi một chuỗi JSON thành một đối tượng JavaScript.

2. `response.json():` Phương thức `json()` là một phương thức của đối tượng `response` trong JavaScript. Khi gọi phương thức này trên đối tượng `response`, nó trả về một lời hứa (promise) mà khi giải quyết (resolved), nó trả về dữ liệu JSON được chuyển đổi thành đối tượng JavaScript.

- Sự khác biệt chính giữa hai phương thức này là `response.json()` không chỉ chuyển đổi JSON thành đối tượng JavaScript, mà nó cũng xử lý việc đọc và xử lý dữ liệu từ phản hồi HTTP. Nó tự động đọc và chuyển đổi phản hồi thành dữ liệu JSON và trả về một hứa chứa đối tượng JavaScript đã chuyển đổi.

- Vì vậy, khi làm việc với phản hồi từ một yêu cầu HTTP, chúng ta sử dụng `response.json()` để thuận tiện đọc và chuyển đổi dữ liệu JSON thành đối tượng JavaScript.

```jsx
import { useMutation } from 'react-query'

const AddStudentForm = () => {
  const mutation = useMutation(addStudent)

  const handleSubmit = (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const newStudent = Object.fromEntries(formData.entries())
    mutation.mutate(newStudent)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type='text' name='name' placeholder='Name' required />
      <input type='text' name='age' placeholder='Age' required />
      <button type='submit' disabled={mutation.isLoading}>
        {mutation.isLoading ? 'Adding...' : 'Add Student'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>Student added successfully!</div>}
    </form>
  )
}
```

- Đoạn code trên định nghĩa một component `AddStudentForm` sử dụng `useMutation` từ React Query để thực hiện thao tác thêm sinh viên mới.

- Trong component `AddStudentForm`, hàm `useMutation` được gọi với đối số là hàm `addStudent` (đã được định nghĩa trước đó) để tạo ra một đối tượng `mutation`. Đối tượng `mutation` chứa các phương thức và trạng thái liên quan đến việc thực hiện mutation (POST) và xử lý kết quả.

- Trong hàm `handleSubmit`, khi người dùng gửi form bằng cách nhấn nút `submit`, sự kiện `submit` được kích hoạt. Hàm `handleSubmit` được gọi và truyền vào đối tượng sự kiện event như tham số.

- Để tránh việc trình duyệt gửi request và refresh trang, hàm `event.preventDefault()` được gọi để ngăn chặn hành vi mặc định của form.

- Sau đó, thông tin từ form được lấy bằng cách tạo một đối tượng `formData` từ `event.target`, đại diện cho form được gửi đi. `FormData` là một đối tượng tích hợp sẵn trong JavaScript cho phép truy cập và xử lý dữ liệu form.

- Tiếp theo, `formData.entries()` trả về một iterator chứa tất cả cặp khóa-giá trị (key-value) trong form data. `Object.fromEntries()` được sử dụng để chuyển đổi iterator này thành một đối tượng JSON `newStudent`, trong đó khóa là tên của các trường form và giá trị là giá trị đã nhập.

- Cuối cùng, `mutation.mutate(newStudent)` được gọi để kích hoạt quá trình mutation (POST) với đối tượng `newStudent` là dữ liệu cần thêm. Quá trình này sẽ được xử lý bởi React Query, bao gồm gửi request lên server, xử lý kết quả và cập nhật cache nếu cần.

- Đoạn code trên giúp kết nối form và việc thực hiện thao tác thêm sinh viên mới thông qua `useMutation`, và cho phép xử lý các tương tác với form và quá trình mutation một cách dễ dàng trong React.

## ❌❌ Hãy định nghĩa phương thức entries() trong JavaScript là gì ?

- Phương thức `entries()` là một phương thức của đối tượng `Object` trong JavaScript. Nó được sử dụng để trả về một mảng chứa các cặp khóa-giá trị (`key-value`) của một đối tượng.

- Khi áp dụng phương thức `entries()` lên một đối tượng, nó sẽ tạo ra một mảng các cặp khóa-giá trị, trong đó mỗi cặp bao gồm một khóa (key) và giá trị (value) của thuộc tính trong đối tượng.

- Ví dụ, xét một đối tượng `person` như sau:

```jsx
const person = {
  name: 'John',
  age: 30,
  occupation: 'Engineer'
}
```

- Khi áp dụng `Object.entries(person)`, kết quả sẽ là một mảng chứa các cặp khóa-giá trị như sau:

```jsx
;[
  ['name', 'John'],
  ['age', 30],
  ['occupation', 'Engineer']
]
```

- Mỗi phần tử trong mảng là một mảng con chứa một cặp khóa-giá trị, trong đó phần tử đầu tiên là khóa và phần tử thứ hai là giá trị tương ứng.

- Phương thức `entries()` rất hữu ích khi bạn muốn lặp qua các thuộc tính của một đối tượng và thực hiện các thao tác trên từng cặp khóa-giá trị trong đối tượng đó.

## ❌❌ Ví dụ về entries() trong JavaScript ?

- Để minh họa cách sử dụng phương thức `entries()`, hãy xem xét ví dụ sau:

```jsx
const person = {
  name: 'John',
  age: 30,
  occupation: 'Engineer'
}

// Sử dụng phương thức entries() để lặp qua các cặp khóa-giá trị trong đối tượng person
for (const [key, value] of Object.entries(person)) {
  console.log(`${key}: ${value}`)
}
```

- Đầu tiên, chúng ta có một đối tượng `person` đại diện cho thông tin về một người. Chúng ta muốn lặp qua các thuộc tính của đối tượng này và hiển thị cặp khóa-giá trị tương ứng.

- Bằng cách sử dụng phương thức `Object.entries(person)`, chúng ta chuyển đổi đối tượng `person` thành một mảng chứa các cặp khóa-giá trị.

- Sau đó, chúng ta sử dụng một vòng lặp `for...of` để lặp qua mảng các cặp khóa-giá trị. Trong mỗi lần lặp, chúng ta gán khóa và giá trị tương ứng cho các biến `key` và `value`. Sau đó, chúng ta hiển thị cặp khóa-giá trị bằng cách sử dụng `console.log()`.

- Kết quả của đoạn mã trên sẽ là:

```jsx
name: John
age: 30
occupation: Engineer
```

- Mỗi dòng đại diện cho một cặp khóa-giá trị trong đối tượng `person`, trong đó `key` là khóa (ví dụ: 'name', 'age', 'occupation') và `value` là giá trị tương ứng (ví dụ: 'John', 30, 'Engineer').

- Điều này cho thấy chúng ta đã lặp qua các thuộc tính của đối tượng `person` và hiển thị cặp khóa-giá trị tương ứng.

## Xử lý lỗi 422 khi submit form bị lỗi trong React Query ?

## Reset error và data trong React Query ?

## Reset formState với mutationAsync trong React Query ?

## Đây là Docs của Được Dev:

Nếu useQuery dùng để GET thì useMutation dùng để POST, PUT, DELETE. Video này tiếp nối video lần trước chúng ta sẽ thực hiện chức năng thêm học sinh 🎉

💓Kiến thức các bạn sẽ được học trong video này:

🎉 Cách phân trang và tối ưu UX với React Query
🎉 Những state quan trọng trong React Query
🎉 Cơ chế caching của React Query

🕰️Nội dung chính

00:00 - add student với useMutation
28:38 - Xử lý lỗi 422 khi submit form bị lỗi
48:20 - reset error và data
50:45 - reset formState với mutationAsync

```

```
