# Redux & Redux Toolkit

## Ôn lại những kiến thức cũ để có thể học Redux hiệu quả hơn

**1. `mutate object` là gì ? Hãy giải thích chi tiết và rõ ràng nhất**

- Trong lập trình, một đối tượng (`object`) được gọi là `immutable` (bất biến) khi giá trị của các thuộc tính của nó không thể thay đổi sau khi đã được khởi tạo. Trái ngược với `immutable` là `mutable` (có thể thay đổi), trong đó giá trị của đối tượng có thể được thay đổi bằng cách thay đổi giá trị của các thuộc tính của nó.

- `Mutate object` (thay đổi giá trị của đối tượng) xảy ra khi giá trị của một thuộc tính của đối tượng được thay đổi bằng cách gán một giá trị mới cho thuộc tính đó.

- Ví dụ, giả sử có đối tượng "`person`" với các thuộc tính "`name`" và "`age`". Nếu ta thay đổi giá trị của thuộc tính "`age`" bằng cách gán giá trị mới, như sau:

```jsx
person.age = 30;
```

- Thì đây được xem là một `mutate object` vì ta đã thay đổi giá trị của thuộc tính "`age`" của đối tượng "`person`".

- Việc `mutate object` có thể gây ra các vấn đề khó giải quyết trong mã của chúng ta, như vấn đề tương thích (compatibility issues) khi đối tượng được truyền giữa các thành phần khác nhau trong ứng dụng hoặc vấn đề về hiệu suất (performance issues) khi đối tượng được sử dụng trong các phép toán lặp lại nhiều lần.

- Để tránh `mutate object`, ta có thể sử dụng các kỹ thuật lập trình bất biến (`immutable programming`), như sử dụng hàm sao chép (`copying functions`) để tạo ra một bản sao của đối tượng trước khi thay đổi nó, hoặc sử dụng các thư viện hỗ trợ lập trình bất biến như `Immutable.js` hoặc `Immer`.

## Ví dụ sau sẽ minh họa cách `mutate` một `object`:

```jsx
const person = {
  name: "John",
  age: 30,
};

// Mutate the object by adding a new property
person.city = "New York";

// Mutate the object by changing the value of an existing property
person.age = 31;

console.log(person); // { name: 'John', age: 31, city: 'New York' }
```

- Đoạn code trên tạo ra một object với tên là `person` và chứa hai thuộc tính `name` và `age`. Sau đó, nó thực hiện hai phép thay đổi trên đối tượng đó (`mutate`) bằng cách thêm thuộc tính `city` và thay đổi giá trị của thuộc tính `age`. Cuối cùng, đoạn code in ra giá trị của đối tượng `person` bằng cách sử dụng hàm `console.log()`.

- Cụ thể hơn, khi ta `mutate object` bằng cách thêm một thuộc tính mới, ta có thể sử dụng cú pháp: `object.newProperty = value`. Tương tự, khi ta muốn thay đổi giá trị của một thuộc tính đã tồn tại, ta có thể sử dụng cú pháp: `object.existingProperty = newValue`.

- Lưu ý rằng khi `mutate object`, đối tượng gốc (`original object`) sẽ bị thay đổi và không còn giống với trạng thái ban đầu. Việc `mutate object` có thể dẫn đến các vấn đề không mong muốn trong quá trình lập trình, đặc biệt là khi sử dụng React. Do đó, trong React, ta thường sử dụng các phương thức bất biến (`immutability methods`) để thay đổi trạng thái của đối tượng, thay vì `mutate object` trực tiếp.

## Hook useReducer và hook useContext được sử dụng thường xuyên nhất trong Redux

### 1. `useReducer`: Hook này cho phép sử dụng Reducer trong functional component của React. Reducer giúp quản lý state của ứng dụng, đặc biệt là trong trường hợp có nhiều hành động khác nhau cần thay đổi state.

- `useReducer` là một trong những hooks cơ bản của React. Nó cho phép bạn quản lý state của một component dưới dạng một object có tính chất bất biến, giúp cho việc quản lý state trong các ứng dụng lớn và phức tạp trở nên dễ dàng hơn. `useReducer` hoạt động giống như một máy giúp bạn quản lý các actions mà bạn thực hiện trên state của component.

- Cách hoạt động của `useReducer` giống như Redux, nó sử dụng một function reducer để cập nhật state dựa trên các actions được gọi. Reducer nhận vào hai tham số đầu vào là state hiện tại và action được dispatch, từ đó nó sẽ trả về một object state mới.

- Cấu trúc của `useReducer` gồm có hai tham số: reducer và initialState. Tham số reducer là một hàm xử lý các actions, trả về một state mới. Tham số initialState là state ban đầu của component.

- Cú pháp sử dụng của `useReducer` như sau:

```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

- Trong đó:

  - `state` là state hiện tại của component.
  - `dispatch` là một hàm giúp bạn gửi các actions đến reducer, từ đó reducer sẽ trả về một state mới và cập nhật state của component.

- Bạn có thể sử dụng `useReducer` trong các trường hợp sau:

  - Khi bạn cần quản lý state của một component lớn hoặc phức tạp.
  - Khi bạn muốn các actions của bạn được xử lý đồng bộ và tránh các race condition.
  - Khi bạn muốn tái sử dụng logic xử lý state của một component trong các component khác.

- Tuy nhiên, khi sử dụng `useReducer`, bạn cần chú ý rằng nó cũng có thể dẫn đến việc code của bạn trở nên phức tạp và khó hiểu nếu không sử dụng đúng cách.

- Ví dụ, giả sử ta có state `count` và hai hành động là `increment` và `decrement`, ta có thể sử dụng `useReducer` để quản lý `state` này như sau:

```jsx
const initialState = {
  count: 0,
};

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return {
        count: state.count + 1,
      };
    case "decrement":
      return {
        count: state.count - 1,
      };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
    </>
  );
}
```

- Đoạn code trên thực hiện tạo một component `Counter` trong đó sử dụng `useReducer` hook của React để quản lý trạng thái của `count`.

- Trước khi sử dụng `useReducer`, ta cần khai báo initial state bằng cách sử dụng object có property là `count`. Sau đó, ta khai báo một hàm reducer để xử lý các `action` được gửi tới từ các `dispatch` function. Trong hàm reducer, ta sử dụng switch-case để xác định loại `action` và cập nhật lại trạng thái của `count` tương ứng.

- Sau đó, ta sử dụng `useReducer` để khởi tạo state và `dispatch` function tương ứng trong component `Counter`. Trong hàm trả về của `Counter`, ta hiển thị giá trị hiện tại của `count` và hai button để `dispatch` các `action` `increment` và `decrement` tương ứng.

- Khi người dùng click vào button `+` hoặc `-`, `dispatch` function được gọi với `action` tương ứng. Hàm reducer sẽ xử lý `action` đó và trả về trạng thái mới, `useReducer` sẽ cập nhật lại state của component `Counter`. Cuối cùng, giá trị mới của `count` được hiển thị trên giao diện.

## function reducer(state, action) {}

- Tại sao trong function reducer lại có 2 tham số `state` và `action` ? Hãy giải thích lý do dễ hiểu nhất ?

  - Trong `Redux`, `state` đại diện cho trạng thái của ứng dụng và `action` đại diện cho hành động được thực hiện để thay đổi trạng thái đó.

  - Trong `useReducer`, cách thức hoạt động tương tự. `reducer` là một hàm nhận vào hai tham số: `state` và `action`. `state` đại diện cho trạng thái hiện tại của ứng dụng và `action` đại diện cho hành động được thực hiện để thay đổi trạng thái.

  - Khi `useReducer` được gọi, nó sẽ gọi `reducer` với `state` hiện tại và `action` tương ứng. Sau đó, `reducer` sẽ xử lý `action` và trả về trạng thái mới cho `useReducer`. Việc sử dụng `action` là để xác định loại hành động và dữ liệu cần thiết để thực hiện hành động đó và cập nhật lại trạng thái mới của ứng dụng.

  - Tóm lại, việc sử dụng hai tham số `state` và `action` trong `reducer` là để thay đổi trạng thái của ứng dụng, với `state` đại diện cho trạng thái hiện tại và `action` đại diện cho hành động được thực hiện để thay đổi trạng thái đó.

## const [state, dispatch] = useReducer(reducer, initialState);

- Tại sao trong `useReducer` lại khai báo `reducer` và `initialState` ? Hãy giải thích lý do vì sao ?

- Trong React, `useReducer` là một Hook cho phép bạn `quản lý trạng thái` của một thành phần bằng cách sử dụng mô hình lập trình hàm (`functional programming pattern`) của `Redux`. Nó giúp bạn `quản lý trạng thái` của một thành phần một cách hiệu quả hơn, đặc biệt là trong những trường hợp trạng thái trở nên phức tạp và phức tạp hơn.

- Trong `useReducer`, ta cần khai báo một hàm `reducer` nhận vào 2 tham số là `state` và `action`. `state` đại diện cho trạng thái hiện tại của thành phần, trong khi `action` đại diện cho hành động được thực hiện lên trạng thái. Hàm `reducer` sẽ dựa trên `action` để trả về một phiên bản cập nhật của `state`.

- Tham số thứ hai của `useReducer` là `initialState`, đại diện cho giá trị ban đầu của trạng thái của thành phần. `initialState` được sử dụng trong trường hợp khi thành phần được `lần đầu render` và trạng thái của nó `chưa được khởi tạo`.

- Vì vậy, `useReducer` sử dụng `reducer` và `initialState` để `quản lý trạng thái` của một thành phần. Khi `reducer` được gọi, nó sẽ trả về một phiên bản mới của `state` dựa trên `action` được thực hiện, và `useReducer` sẽ cập nhật trạng thái mới đó và render lại thành phần.

## const [state, dispatch] = useReducer(reducer, initialState);

- Trong `useReducer` đó reducer và initialState được gọi là có 2 `tham số` hay là `đối số` ?

- Trong `useReducer`, `reducer` và `initialState` được gọi là hai tham số (hoặc đối số).

- Cụ thể, `reducer` là một hàm nhận vào hai đối số là `state` và `action` và trả về một giá trị mới của `state`. `initialState` là giá trị ban đầu của `state`.

- Trong hàm `useReducer`, chúng ta truyền hai tham số này vào để tạo ra một `state` mới và một `dispatch` function để gửi các `action` đến `reducer`.

## dispatch({ type: "increment" })

## dispatch({ type: "decrement" })

## 2 dòng code này có nghĩa là `dispatch` gửi `action` lên `reducer` để cập nhật lại `state` hả ?

- Đúng rồi, `dispatch` là một hàm mà ta gọi để gửi một `action` lên `reducer` để thay đổi `state`. Trong ví dụ của bạn, khi người dùng click vào button "+" hoặc "-", ta sẽ gọi `dispatch` để gửi `action` lên `reducer`.

- Trong trường hợp của bạn, `action` có dạng `{ type: "increment" }` hoặc `{ type: "decrement" }`, nó cho biết rằng `reducer` cần thực hiện hành động tương ứng để thay đổi `state`. Ở ví dụ trên, `reducer` sẽ tăng giá trị của count lên 1 nếu nhận được `action` có type là `"increment"`, và giảm giá trị count đi 1 nếu nhận được `action` có type là `"decrement"`.

## Vì sao `action` lại có dạng là `object` như này: `{ type: "increment" }`

## Mà không phải có dạng `array` như này: `[type: "increment" ]`

- `Action` trong `Redux` là một `plain object` (đối tượng thuần túy) vì nó cần mang thông tin mô tả về sự thay đổi dữ liệu đang xảy ra trong ứng dụng. Mỗi `object action` bao gồm ít nhất một thuộc tính `type` để định danh kiểu `hành động` đó.

- Ví dụ, `{ type: "increment" }` là một `action` được sử dụng để tăng giá trị của một thuộc tính trong `state` của ứng dụng. Các thuộc tính khác có thể được thêm vào `action` tùy theo nhu cầu, nhưng `type` là `bắt buộc` và được coi là thông tin cần thiết để `phân biệt` các loại `hành động` trong ứng dụng.

- Các `action` không phải là một `mảng` (array) vì một `mảng` thường được sử dụng để lưu trữ một `danh sách` các phần tử giống nhau, trong khi các `action` có thể có các `thuộc tính` khác nhau tùy theo từng trường hợp sử dụng. Sử dụng `object action` cũng giúp cho việc đọc và xử lý code trở nên dễ dàng và dễ hiểu hơn.

## Trong `action` gồm những thành phần nào ?

- Trong `Redux`, một `action` là một `plain JavaScript object` (đối tượng JavaScript đơn giản) và bắt buộc phải có một thuộc tính `type` (kiểu) để xác định loại `action` đó. Thuộc tính `type` thường là một chuỗi đơn giản nhưng bạn cũng có thể sử dụng một kiểu khác như một ký hiệu số hoặc một ký hiệu động.

- Ngoài ra, các thuộc tính khác có thể được thêm vào để truyền thêm thông tin liên quan đến `action` đó.

- Ví dụ, một `action` có thể có cấu trúc như sau:

```jsx
{
  type: 'ADD_TODO',
  payload: {
    id: 1,
    text: 'Learn Redux',
    completed: false
  }
}
```

- Ở đây, `type` là thuộc tính `bắt buộc`, còn `payload` là một thuộc tính `tùy chọn` và chứa các thông tin cụ thể về `action`.

## `payload` có phải là thuộc tính bắt buộc của `action` không ?

- Không, `payload` không phải là thuộc tính `bắt buộc` của `action`. `Payload` được sử dụng để chứa thông tin cần thiết để thực hiện thay đổi trên `state`.

- Trong một số trường hợp, một `action` có thể không cần `payload` nếu chỉ thực hiện một hành động đơn giản mà không cần dữ liệu bổ sung. Ví dụ: `action` có `type` là `"increment"` hoặc `"decrement"` không cần `payload` vì chỉ cần tăng hoặc giảm giá trị hiện tại của `state`.

### 2. `useContext` là gì ?

- `useContext` là một trong những hook cơ bản của React, cho phép bạn truy cập vào `context` được cung cấp bởi `Provider` và sử dụng các giá trị được cung cấp bởi `context` đó trong các thành phần của ứng dụng React mà không cần truyền `props` xuống từng cấp con của component tree.

- `Context` trong React là một cơ chế để chia sẻ dữ liệu giữa các thành phần mà không cần truyền dữ liệu qua lại qua `props`, giúp làm giảm đáng kể việc lồng ghép các thành phần. Khi sử dụng `context`, bạn sẽ cung cấp một giá trị (hoặc một đối tượng giá trị) trong một `Provider` và sử dụng nó trong các thành phần khác bằng cách sử dụng `useContext`.

- Về vai trò trong `Redux`, `useContext` cho phép truy cập trực tiếp đến `store Redux` (được cung cấp bởi `Provider`) từ các thành phần React mà không cần thông qua việc truyền `props`. Nhờ đó, bạn có thể truy cập trực tiếp vào các hàm `dispatch` của `store` và thay đổi `state` của `store`.

- Trong khi đó, `useReducer` cho phép bạn tạo ra các `reducer` để xử lý các `action` và cập nhật lại `state` của `store`.

- Vì vậy, cả hai hook đều có vai trò rất quan trọng trong việc sử dụng `Redux`.

## Trong `TypeScript` chúng ta cần phải `nắm vững` cái gì để có thể code `thành thạo` được nó ?

1. Cú pháp TypeScript: TypeScript sử dụng cú pháp tương tự với JavaScript, nhưng có thêm các kiểu dữ liệu, interface, class, generic, enum và nhiều tính năng khác. Bạn cần phải nắm vững cú pháp này để có thể viết được code TypeScript.

2. Kiểu dữ liệu: TypeScript hỗ trợ nhiều kiểu dữ liệu, bao gồm các kiểu cơ bản như string, number, boolean, object, array, tuple, any, void, null và undefined, cũng như các kiểu phức tạp hơn như union, intersection, enum và type alias. Bạn cần phải biết cách sử dụng các kiểu này để có thể xác định kiểu dữ liệu của các biến, tham số và giá trị trả về của hàm.

3. Interface và type: TypeScript hỗ trợ hai cách để xác định kiểu dữ liệu: interface và type. Interface được sử dụng để định nghĩa kiểu cho các đối tượng, trong khi type được sử dụng để định nghĩa kiểu cho các biến và hàm. Bạn cần phải nắm vững cách sử dụng interface và type để có thể tạo ra các kiểu dữ liệu phức tạp và dễ dàng tái sử dụng.

4. Class và object-oriented programming (`OOP`): TypeScript hỗ trợ `OOP` và có thể sử dụng class để định nghĩa các đối tượng. Bạn cần phải nắm vững cách sử dụng class và các khái niệm liên quan đến `OOP` như `kế thừa`, `đa hình` và `trừu tượng` để có thể viết `code OOP` hiệu quả.

5. Generic: TypeScript hỗ trợ generic để tạo ra các hàm hoặc lớp có thể hoạt động với nhiều kiểu dữ liệu khác nhau. Bạn cần phải nắm vững cách sử dụng generic để có thể tạo ra các hàm tái sử dụng được cho nhiều kiểu dữ liệu.

6. Module và namespace: TypeScript hỗ trợ module và namespace để tạo ra các module độc lập và giúp quản lý mã nguồn dễ dàng hơn. Bạn cần phải nắm vững cách sử dụng module và namespace để có thể tổ chức mã nguồn của mình một cách hiệu quả.

7. Type checking: TypeScript kiểm tra kiểu dữ liệu trong quá trình phát triển và báo lỗi nếu có bất kỳ sai sót nào. Điều này giúp đảm bảo rằng mã JavaScript được viết sẽ chạy đúng, tránh được những lỗi phát sinh tại runtime.

8. Debugging: TypeScript cho phép sử dụng tính năng debugging trong các IDE phổ biến như Visual Studio Code hay WebStorm. Điều này giúp giảm thiểu thời gian tìm kiếm lỗi và nâng cao hiệu suất của nhà phát triển.

9. Refactoring: Nhờ vào tính năng type checking, TypeScript giúp cho việc refactor code trở nên dễ dàng hơn. Khi thay đổi một phần của code, TypeScript sẽ kiểm tra và báo lỗi nếu có ảnh hưởng đến các phần khác trong code.

10. Tooling: Cộng đồng TypeScript đang ngày càng phát triển và cung cấp rất nhiều công cụ hỗ trợ như linters, code formatters, và code editors để giúp cho việc phát triển ứng dụng trở nên dễ dàng và tiện lợi hơn.

11. Codebase Maintainability: Sử dụng TypeScript giúp cho codebase trở nên dễ bảo trì hơn, giúp tăng năng suất và đảm bảo tính ổn định của hệ thống.

12. Performance: TypeScript giúp cải thiện hiệu suất của ứng dụng bằng cách tối ưu hóa và kiểm tra kiểu dữ liệu. Tính năng này giúp giảm thiểu tài nguyên và thời gian xử lý của ứng dụng.

13. Collaboration: TypeScript giúp các nhà phát triển làm việc cùng nhau một cách hiệu quả hơn bằng cách giúp tăng tính đồng nhất và minh bạch của codebase.

## Chuẩn bị gì để học series `Redux Toolkit` Typescript này

Yêu cầu:

- React hook cơ bản
- Hiểu mutate object là gì
- Biết sơ sơ Typescript
- Cài extension Redux Devtools trên trình duyệt

Sẽ thật tuyệt nếu bạn:

- Đã biết cách hoạt động `useReducer` và `useContext`

## Redux là gì?

- Redux là một state container cho Javascript apps.

- Là một single store chứa global state
- Thực hiện event => Dispatch các object action vào store => reducer lắng nghe và trả về state update

Với React thì Redux giúp tạo 1 global state, giúp dễ dàng truyền state xuống các component khác nhau mà không gặp phải vấn đề truyền prop quá nhiều bước (cách giải quyết tương tự `useContext`)

> Redux giống như `useReducer` + `useContext`

- Bạn có thể dùng Redux với bất kỳ thư viện view nào, nhưng thường thì người ta dùng với React.

- Đây là cách viết Redux core

```js
const ADD_TODO = "ADD_TODO";
const TODO_TOGGLED = "TODO_TOGGLED";

// function tạo action, nó return một plain object
export const addTodo = (text) => ({
  type: ADD_TODO,
  payload: { text, id: nanoid() },
});

export const todoToggled = (id) => ({
  type: TODO_TOGGLED,
  payload: id,
});

export const todosReducer = (state = [], action) => {
  switch (action.type) {
    case ADD_TODO:
      return state.concat({
        id: action.payload.id,
        text: action.payload.text,
        completed: false,
      });
    case TODO_TOGGLED:
      return state.map((todo) => {
        if (todo.id !== action.payload.id) return todo;

        return {
          ...todo,
          completed: !todo.completed,
        };
      });
    default:
      return state;
  }
};
```

### Data Flow

- Data flow một chiều của redux có thể tóm gọn như sau:

- User click thì sẽ dispatch một action
- reducer lắng nghe các action trong app và xử lý tính toán để trả về một state mới
- component đọc state mới và cập nhật lại UI

> **Data flow theo set state thông thường**
>
> - User click thì sẽ set state với một giá trị mới
> - component đọc state mới và cập nhật lại UI
>
> Flow của set state ngắn hơn so với reducer

![Redux Data Flow](./ReduxDataFlowDiagram.gif)

- Redux sử dụng một vài **thuật ngữ**

- **action**: là một plain object (object đơn giản tạo bằng `{}` hoặc `new Object()`) chứa field là `type` mô tả chuyện gì vừa xảy ra. action là một object nhưng chúng ta thường khai báo là một function return về object để có thể dễ dàng gửi data vào action. Chúng ta thường gọi đó là `payload`
- **reducer**: là một function để tính toán state mới dựa vào previous state + action
- **store**: store sẽ chạy root reducer bất cứ khi nào một action được dispatch
- **dispatch**: là một function dùng để gửi một action đi đến store (hay còn gọi reducer cũng được)

> Store là một object chứa state tree. Chỉ nên có duy nhất 1 store trong app.

```jsx
type Store = {
  dispatch: Dispatch,
  getState: () => State,
  subscribe: (listener: () => void) => () => void,
  replaceReducer: (reducer: Reducer) => void,
};
```

- Có một vấn đề là chỉ để thay đổi một state mà chúng ta tạo ra quá nhiều code thừa: tạo constants, actions, cập nhật state làm sao để không phải mutate state gốc. Và vấn đề này lặp đi lặp lại một cách nhàm chán => Team Redux tạo ra Redux Toolkit để giải quyết vấn đề này

## Redux Toolkit là gì?

- Redux Toolkit sinh ra để đơn giản quá cách chúng ta làm việc với redux, tập trung vào logic hơn là những "boilerplate" không cần thiết.

> Redux Toolkit mới ra ~ 2018, vậy nên trước đó người ta chỉ dùng Redux thôi. Vì thế một số dự án các bạn join sau này có thể vẫn còn dùng Redux với cách tiếp cận cũ.

> Team Redux đều recommend dùng Redux Toolkit trên cả trang [https://redux.js.org/](https://redux.js.org/) và [https://react-redux.js.org/](https://react-redux.js.org/)

Bây giờ sẽ có các document sau:

- Document chính thức của Redux: [https://redux.js.org/](https://redux.js.org/)
- Document chính thức của Redux cho React: [https://react-redux.js.org/](https://react-redux.js.org/)
- Document chính thức của Redux-Toolkit: [https://redux-toolkit.js.org/](https://redux-toolkit.js.org/)

> Chúng ta có thể bỏ qua bước tạo một project bằng redux kiểu cũ, vì đơn giản là nó giống `useReducer` và `useContext`. Học luôn redux toolkit cho tiết kiệm thời gian

- Redux Toolkit bao gồm các packages nhỏ sau:

  - Redux
  - ImmerJs: Dùng làm việc với immutable state thuận tiện hơn (cập nhật state dễ dàng)
  - RTK query: Fetch & catching API

- Cách cài bộ redux toolkit vào app:

```bash
yarn add react-redux @reduxjs/toolkit
```
